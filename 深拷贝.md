# 手写深拷贝（JavaScript，带详细注释）

**JSON 方法**
```
// 不支持值为undefined、函数和循环引用的情况
const cloneObj = JSON.parse(JSON.stringify(obj))
// 上述方法有诸多局限性，例 如无法拷贝函数、Date对象、RegExp对象、Map、Set等复杂数据类型
```

以下实现尽量覆盖常见类型与场景：
- 原始值直接返回
- Date、RegExp、Map、Set、ArrayBuffer、TypedArray、DataView 等特殊对象正确克隆
- 保留原型链（prototype）
- 保留属性描述符（包括不可枚举属性、符号键、访问器 getter/setter）
- 支持循环引用（使用 WeakMap）
- 注意：函数按引用复制（函数体无法安全克隆），DOM 节点、外部宿主对象也不保证能克隆

示例代码（将其粘贴到 .md 中的代码块或 .js 文件）：

```javascript
/**
 * 深拷贝函数
 * - 支持常见内建对象
 * - 保留原型与属性描述符
 * - 处理循环引用
 *
 * 注意：
 * - 函数作为引用返回（不会克隆函数实现）；函数自身如果有自定义属性，不会被克隆到新的函数上。
 * - 主动宿主对象（如 DOM 节点）不保证能正确克隆。
 */
function deepClone(value, seen = new WeakMap()) {
    // 处理 null 与原始类型（number/string/boolean/undefined/bigint/symbol）
    if (value === null) return null;
    const type = typeof value;
    if (type !== 'object' && type !== 'function') return value;

    // 函数：直接返回（可按需改为复制属性到原函数，但通常不克隆函数体）
    if (type === 'function') return value;

    // 处理循环引用
    if (seen.has(value)) return seen.get(value);

    // Date
    if (value instanceof Date) return new Date(value.getTime());

    // RegExp
    if (value instanceof RegExp) return new RegExp(value.source, value.flags);

    // ArrayBuffer
    if (value instanceof ArrayBuffer) return value.slice(0);

    // TypedArray（包括 Uint8Array, Int32Array 等）与 DataView
    if (ArrayBuffer.isView(value)) {
        // DataView 需要特殊处理
        if (value instanceof DataView) {
            const bufferCopy = value.buffer.slice(0);
            return new DataView(bufferCopy, value.byteOffset, value.byteLength);
        }
        // 对于 TypedArray，直接用构造函数复制（会复制内容）
        const ctor = value.constructor;
        return new ctor(value);
    }

    // Map
    if (value instanceof Map) {
        const result = new Map();
        seen.set(value, result);
        for (const [k, v] of value.entries()) {
            result.set(deepClone(k, seen), deepClone(v, seen));
        }
        return result;
    }

    // Set
    if (value instanceof Set) {
        const result = new Set();
        seen.set(value, result);
        for (const v of value.values()) {
            result.add(deepClone(v, seen));
        }
        return result;
    }

    // 普通对象或数组或自定义类的实例
    // 保留原型
    const proto = Object.getPrototypeOf(value);
    const cloneObj = Object.create(proto);
    // 先放入缓存以处理循环引用
    seen.set(value, cloneObj);

    // 获取所有自身属性的描述符（包含不可枚举、符号键）
    const descriptors = Object.getOwnPropertyDescriptors(value);

    // 遍历所有键（包括符号），如果是数据描述符，就递归拷贝 value
    Reflect.ownKeys(descriptors).forEach((key) => {
        const desc = descriptors[key];
        if ('value' in desc) {
            // 数据属性，递归深拷贝属性值
            desc.value = deepClone(desc.value, seen);
        }
        // 若是访问器属性（get/set），这里直接复制 getter/setter 函数引用（通常期望如此）
        Object.defineProperty(cloneObj, key, desc);
    });

    return cloneObj;
}

/* 使用示例 */
const a = { num: 1, date: new Date(), nested: { s: 'str' } };
a.self = a; // 循环引用
const b = deepClone(a);
console.log(b);
console.log(b.self === b); // true
```

补充说明（简要）：
- 保留属性描述符可以把不可枚举、只读、访问器等信息复制过去，尽量保证拷贝后对象行为与原对象一致。
- 性能：此实现侧重正确性而非极致性能；对大量数据或深递归可能较慢，需根据场景优化（如基于 structuredClone / postMessage / third-party libs）。
- 在支持的环境中（现代浏览器、Node 17+），可以优先考虑内置的 structuredClone，它能安全且高效地处理大部分深拷贝场景（包括循环引用、Map/Set 等），但不保留函数和某些自定义类原型行为。

如果需要，我可以把实现改为更轻量（只拷贝可枚举属性）或扩展对函数、特殊类实例（如 Error、Promise）更完整的处理。
```
